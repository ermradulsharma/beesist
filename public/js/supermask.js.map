{"version":3,"file":"/js/supermask.js","mappings":"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","sources":["webpack:///./resources/js/supermask.js"],"sourcesContent":["\"use strict\"\n\nString.prototype.isSymbol = function () {\n  return !!this.match(/(?![Ã])(?![Á])[_\\W]/)\n}\n\nString.prototype.isLowerCaseLetter = function () {\n  return !!this.match(/[a-z]/)\n}\n\nString.prototype.isUpperCaseLetter = function () {\n  return !!this.match(/[A-Z]/)\n}\n\nString.prototype.isLetter = function () {\n  return !!this.match(/[a-z\\A-Z]/)\n}\n\nfunction _getMaskFields() { \n  return Array.from(document.getElementsByClassName('maskField'))\n}\n\nfunction _getMasks(maskFields) {\n  return maskFields.map(input => input.getAttribute(\"mask\"))\n}\n\nfunction _shouldThisInvalidDigitBeHere(digit, mask) {\n  return digit == mask\n}\n\nlet maskFields = _getMaskFields()\nlet masks = _getMasks(maskFields)\n_setupMaskEvents(maskFields, masks)\n\n// Constructor function\nfunction _setupMaskEvents(maskFields, masks) {\n  maskFields.forEach((field, index) => {\n    field.addEventListener('input', (event) => {\n      switch (event.inputType) {\n        case \"deleteContentForward\":\n          _validateBackspaceButton(field, masks[index], \"delete\")\n          break\n\n        case \"deleteContentBackward\":\n          _validateBackspaceButton(field, masks[index])\n          break\n\n        case \"insertFromDrop\":\n          fullyValidateChange(field, masks[index], event)\n          break\n      }\n    })\n    field.addEventListener('keypress', (event) => {\n      validateMask(field, masks[index], event)\n    })\n    field.addEventListener('change', (event) => fullyValidateChange(field, masks[index], event))\n    field.addEventListener('paste', (event) => {\n      if (!field.hasAttribute(\"blockpasting\")) {\n        field.value = (event.clipboardData || window.clipboardData).getData('text')\n        fullyValidateChange(field, masks[index], event)\n      }\n      event.preventDefault()\n    })\n  })\n}\n\n// Function to validate mask on type, it'll also add symbols\nfunction validateMask(field, mask, event) {\n  let lastDigitPosition = field.value.length\n  let splitMask = mask.split('')\n\n  try {\n    if (!_validateDigit(splitMask, lastDigitPosition, event.key, field))\n      event.preventDefault()\n  } catch (e) {\n    event.preventDefault()\n  }\n}\n\n// Capsule function to validate field value after focusout\nfunction fullyValidateChange(field, mask, event) {\n  _addSymbols(field, mask)\n  fullyValidateMask(field, mask, event)\n}\n\n// Function to validate every digit\nfunction fullyValidateMask(field, mask, event) {\n  let validatedMask = ''\n  let finalSymbols = _getFinalMaskSymbols(mask)\n\n  try {\n\n    field.value.split('').forEach((digit, index) => {\n\n      if (_validateDigit(mask.split(''), index, digit, field, true))\n        return validatedMask = validatedMask.concat(digit)\n\n      if (_shouldThisInvalidDigitBeHere(digit, mask[index]))\n        return validatedMask = validatedMask.concat(digit)\n\n      throw 'invalid input'\n\n    })\n\n  } catch (e) {\n    return field.value = validatedMask + finalSymbols.join('')\n  }\n}\n\n// Function used to catch any symbols a mask might have at the end (such as AAA---)\nfunction _getFinalMaskSymbols(mask) {\n  let finalSymbols = []\n  let reverseSplitMask = mask.split('').reverse()\n  try {\n    reverseSplitMask.forEach(digit => {\n      if (digit.isSymbol()) finalSymbols.push(digit)\n      else throw \"Reached a non-symbolic value\"\n    })\n  } catch (e) { }\n  return finalSymbols\n}\n\n// Will add every symbol the mask should have\nfunction _addSymbols(field, mask) {\n  if (field.value.length == 0) return field.value\n  let splitMask = mask.split('')\n  let splitValue = field.value.split('')\n\n  try {\n    splitMask.forEach((digit, index) => {\n      if (index > splitValue.length) throw \"mask is bigger than input value\"\n      if (digit.isSymbol() && splitValue[index] != digit)\n        splitValue = _insertSymbol(splitValue.join(''), index, digit).split('')\n    })\n  } catch (e) { }\n  field.value = splitValue.join('')\n}\n\n// Function used to insert symbol at specific position\nfunction _insertSymbol(fieldValue, index, symbol) {\n  let splitValue = fieldValue.split('')\n  let firstHalf = fieldValue.substr(0, index)\n  let secondHalf = splitValue.splice(index).join('')\n  return firstHalf + symbol + secondHalf\n}\n\n//Function to make backspace unable to delete a symbol at the middle of the field\nfunction _validateBackspaceButton(field, mask, deletionType = \"backspace\") {\n  let caretPosition = _getCaretPos(field)\n  let deletedCharacter = mask[caretPosition]\n\n  if (deletedCharacter.isSymbol() && field.value.split('')[caretPosition]) {\n    field.value = _insertSymbol(field.value, caretPosition, deletedCharacter)\n\n    switch (deletionType) {\n      case \"backspace\":\n        _setCaretPosition(field, caretPosition)\n        break\n\n      case \"delete\":\n        _setCaretPosition(field, caretPosition + 1)\n        break\n    }\n\n  }\n}\n\n// Will validate a specific digit of the mask\nfunction _validateDigit(splitMask, lastDigitPosition, key, field, isFullValidation = false) {\n  let digitMask = splitMask[lastDigitPosition]\n\n  if (key == ' ')\n    return false\n\n  if (digitMask.isSymbol()) {\n    if (!isFullValidation) {\n      field.value = _concatSymbols(field, splitMask, lastDigitPosition)\n      return _validateDigit(splitMask, field.value.length, key, field)\n    }\n    return _validateDigit(splitMask, (lastDigitPosition + 1), key, field, true)\n  }\n\n  if (+digitMask || digitMask == \"0\")\n    return _numericValidation(digitMask, key, field)\n\n  if (digitMask.isUpperCaseLetter() && key.isUpperCaseLetter())\n    return true\n\n  if (digitMask.isLowerCaseLetter() && key.isLowerCaseLetter())\n    return true\n\n  if (digitMask == \"Á\" && key.isLetter())\n    return true\n\n  if (digitMask == \"Ã\")\n    return true\n\n}\n\n// Function to concat symbols at the end of mask\nfunction _concatSymbols(field, splitMask, lastDigitPosition) {\n  let symbols = ''\n  for (let i = lastDigitPosition; i < splitMask.length; i++)\n    if (splitMask[i].isSymbol()) symbols = symbols.concat(splitMask[i])\n    else break\n\n  return field.value.concat(symbols)\n}\n\n// Will set the carret position\nfunction _setCaretPosition(field, caretPos) {\n  if (field.createTextRange) {\n    let range = field.createTextRange()\n    range.move('character', caretPos)\n    range.select()\n  }\n  else if (field.selectionStart) {\n    field.focus()\n    field.setSelectionRange(caretPos, caretPos)\n  }\n  else field.focus()\n}\n\n// Will get the carret position\nfunction _getCaretPos(field) {\n  let range, bookmark, caret_pos\n  if (document.selection && document.selection.createRange) {\n    range = document.selection.createRange()\n    bookmark = range.getBookmark()\n    caret_pos = bookmark.charCodeAt(2) - 2\n  } else if (field.setSelectionRange)\n    caret_pos = field.selectionStart\n\n  return caret_pos\n}\n\n// Will validate a number in a specific position\nfunction _numericValidation(digitMask, key, field) {\n  if (field.hasAttribute(\"inverted-numbers\"))\n    if (+key >= digitMask)\n      return true\n    else return false\n\n  else if (+key <= digitMask)\n    return true\n\n  else return false\n}\n"],"names":["String","prototype","isSymbol","this","match","isLowerCaseLetter","isUpperCaseLetter","isLetter","maskFields","Array","from","document","getElementsByClassName","masks","map","input","getAttribute","_getMasks","fullyValidateChange","field","mask","event","value","length","splitMask","split","splitValue","forEach","digit","index","_insertSymbol","join","e","_addSymbols","validatedMask","finalSymbols","reverseSplitMask","reverse","push","_getFinalMaskSymbols","_validateDigit","concat","_shouldThisInvalidDigitBeHere","fullyValidateMask","fieldValue","symbol","substr","splice","_validateBackspaceButton","deletionType","arguments","undefined","caretPosition","caret_pos","selection","createRange","getBookmark","charCodeAt","setSelectionRange","selectionStart","_getCaretPos","deletedCharacter","_setCaretPosition","lastDigitPosition","key","isFullValidation","digitMask","symbols","i","_concatSymbols","hasAttribute","_numericValidation","caretPos","createTextRange","range","move","select","focus","addEventListener","inputType","preventDefault","validateMask","clipboardData","window","getData","_setupMaskEvents"],"sourceRoot":""}